<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arena Shooter - 8 Players</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Arial Black', 'Impact', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        padding: 20px;
        border-radius: 15px;
        font-size: 18px;
        z-index: 100;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        border: 3px solid rgba(255, 255, 255, 0.3);
        font-weight: bold;
      }
      #info div {
        margin: 8px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      #leaderboard {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        padding: 20px;
        border-radius: 15px;
        font-size: 16px;
        z-index: 100;
        min-width: 220px;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        border: 3px solid rgba(255, 255, 255, 0.3);
      }
      #leaderboard h3 {
        margin: 0 0 15px 0;
        color: #ffeb3b;
        font-size: 22px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      .player-item {
        display: flex;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 24px;
        height: 24px;
        border: 3px solid #ff1744;
        border-radius: 50%;
        pointer-events: none;
        z-index: 100;
        box-shadow: 0 0 10px rgba(255, 23, 68, 0.8);
      }
      #crosshair::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 3px;
        height: 3px;
        background: #ff1744;
        box-shadow: 0 0 5px #ff1744;
      }
      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 50px;
        border-radius: 20px;
        text-align: center;
        display: none;
        z-index: 200;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.6);
        border: 4px solid rgba(255, 255, 255, 0.3);
      }
      #gameOver h1 {
        margin: 0 0 20px 0;
        color: #ffeb3b;
        font-size: 48px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
      }
      #gameOver button {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: 3px solid rgba(255, 255, 255, 0.5);
        padding: 18px 40px;
        font-size: 20px;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s;
      }
      #gameOver button:hover {
        transform: scale(1.1);
      }
      #startScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 50px;
        border-radius: 20px;
        text-align: center;
        z-index: 200;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.6);
        border: 4px solid rgba(255, 255, 255, 0.3);
      }
      #startScreen h1 {
        margin: 0 0 20px 0;
        color: #ffeb3b;
        font-size: 42px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
      }
      #startScreen input {
        padding: 15px;
        font-size: 16px;
        margin: 10px 0;
        width: 100%;
        border-radius: 10px;
        border: 3px solid rgba(255, 255, 255, 0.5);
        background: rgba(255, 255, 255, 0.2);
        color: white;
        font-weight: bold;
      }
      #startScreen input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }
      #startScreen button {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: 3px solid rgba(255, 255, 255, 0.5);
        padding: 18px 40px;
        font-size: 20px;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        display: block;
        width: 100%;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s;
      }
      #startScreen button:hover {
        transform: scale(1.05);
      }
      #connectionStatus {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: white;
        background: linear-gradient(135deg, #434343 0%, #000000 100%);
        padding: 12px 20px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        border: 2px solid rgba(255, 255, 255, 0.3);
        font-weight: bold;
      }
      .online {
        color: #76ff03;
        text-shadow: 0 0 5px #76ff03;
      }
      .offline {
        color: #ff1744;
        text-shadow: 0 0 5px #ff1744;
      }
      #authScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 50px;
        border-radius: 20px;
        text-align: center;
        color: white;
        z-index: 200;
        min-width: 400px;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.6);
        border: 4px solid rgba(255, 255, 255, 0.3);
      }
      #authScreen h1 {
        color: #ffeb3b;
        font-size: 42px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        margin-bottom: 10px;
      }
      #authScreen h2 {
        color: #4facfe;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      #authScreen input {
        width: 100%;
        padding: 15px;
        margin: 10px 0;
        border: 3px solid rgba(255, 255, 255, 0.5);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 16px;
        font-weight: bold;
      }
      #authScreen input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }
      #authScreen button {
        width: 100%;
        padding: 18px;
        margin: 10px 0;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border: 3px solid rgba(255, 255, 255, 0.5);
        border-radius: 10px;
        color: white;
        font-size: 18px;
        cursor: pointer;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s;
      }
      #authScreen button:hover {
        transform: scale(1.05);
      }
      .auth-toggle {
        color: #ffeb3b;
        cursor: pointer;
        text-decoration: underline;
        margin-top: 15px;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }
      .error-msg {
        color: #ff1744;
        margin: 10px 0;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }
      .stats-display {
        margin-top: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        font-size: 16px;
        font-weight: bold;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
      .stats-display div {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <div id="authScreen">
      <h1>‚öîÔ∏è Arena Shooter</h1>
      <div id="loginForm">
        <h2>Login</h2>
        <input type="text" id="loginUsername" placeholder="Username" maxlength="15" />
        <input type="password" id="loginPassword" placeholder="Password" />
        <div class="error-msg" id="loginError"></div>
        <button onclick="login()">Login</button>
        <p class="auth-toggle" onclick="showRegister()">Don't have an account? Register</p>
      </div>
      <div id="registerForm" style="display: none;">
        <h2>Register</h2>
        <input type="text" id="registerUsername" placeholder="Username (3-15 chars)" maxlength="15" />
        <input type="password" id="registerPassword" placeholder="Password (min 6 chars)" />
        <div class="error-msg" id="registerError"></div>
        <button onclick="register()">Register</button>
        <p class="auth-toggle" onclick="showLogin()">Already have an account? Login</p>
      </div>
    </div>
    <div id="startScreen" style="display: none;">
      <h1>‚öîÔ∏è Arena Shooter (8 Players)</h1>
      <p>Welcome, <span id="welcomeUsername"></span>!</p>
      <div class="stats-display">
        <div>Total Kills: <span id="totalKills">0</span></div>
        <div>Total Deaths: <span id="totalDeaths">0</span></div>
        <div>Games Played: <span id="gamesPlayed">0</span></div>
      </div>
      <p style="font-size: 14px; margin-top: 20px">
        WASD - Move | Mouse - Look | Click - Shoot | R - Reload | Space - Jump
      </p>
      <button onclick="joinGame()">Join Game</button>
      <button onclick="logout()" style="background: #f44336; margin-top: 10px;">Logout</button>
    </div>
    <div id="info" style="display: none">
      <div>Health: <span id="health">100</span></div>
      <div>Kills: <span id="kills">0</span></div>
      <div>Deaths: <span id="deaths">0</span></div>
      <div>Ammo: <span id="ammo">30</span></div>
      <div style="margin-top: 10px; font-size: 12px">
        WASD - Move | Mouse - Look | Click - Shoot | R - Reload | Space - Jump | ESC - Exit Fullscreen
      </div>
    </div>
    <div id="leaderboard" style="display: none">
      <h3>üèÜ Leaderboard</h3>
      <div id="playerList"></div>
    </div>
    <div id="crosshair" style="display: none"></div>
    <div id="gameOver">
      <h1>Game Over!</h1>
      <p>Your Final Score: <span id="finalScore">0</span></p>
      <div id="finalLeaderboard"></div>
      <button onclick="location.reload()">Play Again</button>
    </div>
    <div id="connectionStatus">
      <span class="offline">‚ö´ Connecting...</span>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Authentication Functions
      let currentUser = null;
      
      // Check if user is already logged in
      fetch('/api/user')
        .then(res => res.json())
        .then(data => {
          if (data.authenticated) {
            currentUser = data;
            showStartScreen(data.username, data.stats);
          }
        });
      
      function showLogin() {
        document.getElementById('loginForm').style.display = 'block';
        document.getElementById('registerForm').style.display = 'none';
        document.getElementById('loginError').textContent = '';
      }
      
      function showRegister() {
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('registerForm').style.display = 'block';
        document.getElementById('registerError').textContent = '';
      }
      
      async function login() {
        const username = document.getElementById('loginUsername').value.trim();
        const password = document.getElementById('loginPassword').value;
        const errorEl = document.getElementById('loginError');
        
        if (!username || !password) {
          errorEl.textContent = 'Please enter username and password';
          return;
        }
        
        try {
          const response = await fetch('/api/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            currentUser = data;
            showStartScreen(data.username, data.stats);
          } else {
            errorEl.textContent = data.error || 'Login failed';
          }
        } catch (error) {
          errorEl.textContent = 'Connection error';
        }
      }
      
      async function register() {
        const username = document.getElementById('registerUsername').value.trim();
        const password = document.getElementById('registerPassword').value;
        const errorEl = document.getElementById('registerError');
        
        if (!username || !password) {
          errorEl.textContent = 'Please enter username and password';
          return;
        }
        
        try {
          const response = await fetch('/api/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            currentUser = data;
            showStartScreen(data.username, data.stats);
          } else {
            errorEl.textContent = data.error || 'Registration failed';
          }
        } catch (error) {
          errorEl.textContent = 'Connection error';
        }
      }
      
      async function logout() {
        await fetch('/api/logout', { method: 'POST' });
        location.reload();
      }
      
      function showStartScreen(username, stats) {
        document.getElementById('authScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'block';
        document.getElementById('welcomeUsername').textContent = username;
        document.getElementById('totalKills').textContent = stats.kills || 0;
        document.getElementById('totalDeaths').textContent = stats.deaths || 0;
        document.getElementById('gamesPlayed').textContent = stats.gamesPlayed || 0;
      }
      
      // Game Code
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      function playShootSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator. frequency.value = 200;
          oscillator.type = 'sawtooth';
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
      }

      function playHitSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode. connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext. currentTime + 0.2);
      }

      function playBullseyeSound() {
          const osc1 = audioContext.createOscillator();
          const gain1 = audioContext.createGain();
          osc1.connect(gain1);
          gain1.connect(audioContext.destination);
          osc1.frequency.value = 1000;
          osc1.type = 'sine';
          gain1.gain.setValueAtTime(0.4, audioContext.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc1.start(audioContext.currentTime);
          osc1.stop(audioContext.currentTime + 0.3);

          const osc2 = audioContext.createOscillator();
          const gain2 = audioContext.createGain();
          osc2.connect(gain2);
          gain2.connect(audioContext.destination);
          osc2.frequency. value = 1500;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.3, audioContext.currentTime + 0.05);
          gain2.gain. exponentialRampToValueAtTime(0.01, audioContext. currentTime + 0.35);
          osc2.start(audioContext.currentTime + 0.05);
          osc2.stop(audioContext. currentTime + 0.35);
      }

      function playReloadSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode. connect(audioContext.destination);
          oscillator.frequency.value = 100;
          oscillator.type = 'square';
          gainNode.gain. setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext. currentTime + 0.15);

          setTimeout(function() {
              const osc2 = audioContext.createOscillator();
              const gain2 = audioContext.createGain();
              osc2.connect(gain2);
              gain2.connect(audioContext.destination);
              osc2.frequency. setValueAtTime(400, audioContext.currentTime);
              osc2.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
              osc2.type = 'sawtooth';
              gain2.gain.setValueAtTime(0.15, audioContext.currentTime);
              gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
              osc2.start(audioContext.currentTime);
              osc2.stop(audioContext.currentTime + 0.3);
          }, 100);
      }

      function playEmptyClickSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.value = 150;
          oscillator.type = 'square';
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.05);
      }

      function playDamageSound() {
          // Red screen flash effect
          const flash = document.createElement('div');
          flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.3);pointer-events:none;z-index:9999;';
          document.body.appendChild(flash);
          setTimeout(() => document.body.removeChild(flash), 100);

          // Pain sound - low thud with descending tone
          const osc1 = audioContext.createOscillator();
          const gain1 = audioContext.createGain();
          osc1.connect(gain1);
          gain1.connect(audioContext.destination);
          osc1.frequency.setValueAtTime(300, audioContext.currentTime);
          osc1.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
          osc1.type = 'sawtooth';
          gain1.gain.setValueAtTime(0.6, audioContext.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc1.start(audioContext.currentTime);
          osc1.stop(audioContext.currentTime + 0.3);

          // Impact sound
          const osc2 = audioContext.createOscillator();
          const gain2 = audioContext.createGain();
          osc2.connect(gain2);
          gain2.connect(audioContext.destination);
          osc2.frequency.value = 80;
          osc2.type = 'triangle';
          gain2.gain.setValueAtTime(0.5, audioContext.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          osc2.start(audioContext.currentTime);
          osc2.stop(audioContext.currentTime + 0.15);
      }

      let socket = null;
      let isOnline = false;
      let playerName = '';
      let playerId = null;
      let health = 100;
      let kills = 0;
      let deaths = 0;
      let ammo = 30;
      let gameActive = false;
      let players = {};
      let otherPlayerMeshes = {};
      let isDead = false;
      let respawnTimer = null;
      
      // Jump variables
      let isJumping = false;
      let verticalVelocity = 0;
      const gravity = -0.015;
      const jumpStrength = 0.3;
      const groundLevel = 1.6;

      const SERVER_URL = window.location.origin;
      try {
          socket = io(SERVER_URL, {
              reconnection: true,
              reconnectionDelay: 1000,
              reconnectionAttempts: 5
          });

          socket.on('connect', function() {
              isOnline = true;
              document.getElementById('connectionStatus').innerHTML = '<span class="online">üü¢ Online</span>';
          });

          socket.on('disconnect', function() {
              isOnline = false;
              document.getElementById('connectionStatus').innerHTML = '<span class="offline">‚ö´ Disconnected</span>';
          });

          socket.on('playerJoined', function(data) {
              players = data.players;
              
              // Remove meshes for players that no longer exist
              for (let meshId in otherPlayerMeshes) {
                  if (!players[meshId]) {
                      console.log('Cleaning up old player mesh:', meshId);
                      scene.remove(otherPlayerMeshes[meshId]);
                      delete otherPlayerMeshes[meshId];
                  }
              }
              
              // Create meshes for any new players we don't have yet
              for (let id in players) {
                  if (id !== playerId && !otherPlayerMeshes[id]) {
                      otherPlayerMeshes[id] = createOtherPlayerMesh(players[id]);
                      otherPlayerMeshes[id].position.set(
                          players[id].position.x,
                          0,
                          players[id].position.z
                      );
                      scene.add(otherPlayerMeshes[id]);
                      console.log('Created mesh for new player:', id);
                  }
              }
              updateLeaderboard();
          });

          socket.on('playerLeft', function(data) {
              players = data.players;
              if (otherPlayerMeshes[data.playerId]) {
                  console.log('Removing player mesh:', data.playerId);
                  scene.remove(otherPlayerMeshes[data.playerId]);
                  delete otherPlayerMeshes[data.playerId];
              }
              updateLeaderboard();
          });

          socket.on('statsUpdate', function(data) {
              players = data.players;
              updateLeaderboard();
          });

          socket.on('playerHit', function(data) {
              if (data.victimId === playerId) {
                  health = data.health;
                  updateUI();
                  
                  // Play damage sound and visual effect
                  playDamageSound();
                  
                  if (health <= 0) {
                      die();
                  }
              }
          });

          socket.on('playerDied', function(data) {
              // Hide the killed player's mesh
              if (otherPlayerMeshes[data.victimId]) {
                  otherPlayerMeshes[data.victimId].visible = false;
              }
          });

          socket.on('playerShot', function(data) {
              // Show muzzle flash for other players shooting
              if (data.shooterId !== playerId && otherPlayerMeshes[data.shooterId]) {
                  const playerMesh = otherPlayerMeshes[data.shooterId];
                  const flash = new THREE.PointLight(0xffaa00, 2, 5);
                  // Position flash at player's head level
                  flash.position.set(
                      playerMesh.position.x,
                      playerMesh.position.y + 2.0,
                      playerMesh.position.z
                  );
                  scene.add(flash);
                  setTimeout(function() {
                      scene.remove(flash);
                  }, 50);
              }
          });

          socket.on('playerRespawned', function(data) {
              // Make sure we update the existing player, not create a new one
              if (data.id !== playerId) {
                  // Show and update the respawned player
                  if (otherPlayerMeshes[data.id]) {
                      otherPlayerMeshes[data.id].visible = true;
                  }
                  updateOtherPlayer(data);
              } else {
                  // Update our own position from server only during respawn, not during normal gameplay
                  if (data.position && isDead) {
                      camera.position.set(data.position.x, data.position.y, data.position.z);
                      if (data.rotation && data.rotation.y !== undefined) {
                          yaw = data.rotation.y;
                      }
                  }
              }
          });

          socket.on('forceRespawn', function(data) {
              // Force respawn if we're stuck dead (inactive tab)
              if (isDead) {
                  const deathMsg = document.getElementById('deathMessage');
                  if (deathMsg) {
                      document.body.removeChild(deathMsg);
                  }
                  
                  isDead = false;
                  health = 100;
                  ammo = 30;
                  camera.position.set(data.position.x, data.position.y, data.position.z);
                  updateUI();
              }
          });

          socket.on('playerMoved', function(data) {
              if (data.id !== playerId) {
                  updateOtherPlayer(data);
              }
          });

          socket.on('maxPlayersReached', function() {
              alert('Arena is full! Maximum 2 players allowed.');
              location.reload();
          });

      } catch (e) {
          console.log('Running in offline mode');
          isOnline = false;
          document.getElementById('connectionStatus').innerHTML = '<span class="offline">‚ö´ Offline Mode</span>';
      }

      // Create procedural textures
      function createGridTexture(color1, color2, size = 512) {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          
          // Background
          ctx.fillStyle = color1;
          ctx.fillRect(0, 0, size, size);
          
          // Grid lines
          ctx.strokeStyle = color2;
          ctx.lineWidth = 3;
          const gridSize = size / 8;
          
          for (let i = 0; i <= 8; i++) {
              ctx.beginPath();
              ctx.moveTo(i * gridSize, 0);
              ctx.lineTo(i * gridSize, size);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(0, i * gridSize);
              ctx.lineTo(size, i * gridSize);
              ctx.stroke();
          }
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(4, 4);
          return texture;
      }
      
      function createStripedTexture(color1, color2, size = 512) {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          
          const stripeWidth = size / 16;
          for (let i = 0; i < 16; i++) {
              ctx.fillStyle = i % 2 === 0 ? color1 : color2;
              ctx.fillRect(0, i * stripeWidth, size, stripeWidth);
          }
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          return texture;
      }
      
      function createDotTexture(baseColor, dotColor, size = 512) {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          
          ctx.fillStyle = baseColor;
          ctx.fillRect(0, 0, size, size);
          
          ctx.fillStyle = dotColor;
          const dotSize = size / 32;
          const spacing = size / 8;
          
          for (let x = 0; x < 8; x++) {
              for (let y = 0; y < 8; y++) {
                  ctx.beginPath();
                  ctx.arc(x * spacing + spacing / 2, y * spacing + spacing / 2, dotSize, 0, Math.PI * 2);
                  ctx.fill();
              }
          }
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(2, 2);
          return texture;
      }

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xFF6B9D);
      scene.fog = new THREE.Fog(0xFF6B9D, 30, 80);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);

      const renderer = new THREE.WebGLRenderer({ antialias: false }); // Disable antialiasing for low-poly look
      renderer.setSize(window.innerWidth, window. innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xFFE66D, 0.7);
      scene.add(ambientLight);

      const sunLight = new THREE.DirectionalLight(0xFFAA00, 1.2);
      sunLight.position.set(10, 20, 10);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -50;
      sunLight.shadow. camera.right = 50;
      sunLight.shadow.camera. top = 50;
      sunLight.shadow.camera.bottom = -50;
      scene.add(sunLight);
      
      // Add colorful accent lights
      const light1 = new THREE.PointLight(0x00F5FF, 0.5, 30);
      light1.position.set(-15, 5, -15);
      scene.add(light1);
      
      const light2 = new THREE.PointLight(0xFF1744, 0.5, 30);
      light2.position.set(15, 5, 15);
      scene.add(light2);

      const groundGeometry = new THREE.PlaneGeometry(40, 40, 8, 8);
      const groundTexture = createGridTexture('#00E676', '#00C853');
      const groundMaterial = new THREE.MeshStandardMaterial({ 
          map: groundTexture,
          flatShading: true,
          roughness: 0.8,
          metalness: 0.1
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Arena walls
      const wallTexture = createStripedTexture('#7C4DFF', '#6200EA');
      const wallMaterial = new THREE.MeshStandardMaterial({ 
          map: wallTexture,
          flatShading: true,
          roughness: 0.7,
          metalness: 0.2
      });
      const wallHeight = 3;
      const arenaSize = 20;
      
      // North wall
      const northWall = new THREE.Mesh(new THREE.BoxGeometry(arenaSize * 2, wallHeight, 0.5), wallMaterial);
      northWall.position.set(0, wallHeight / 2, -arenaSize);
      northWall.castShadow = true;
      scene.add(northWall);
      
      // South wall
      const southWall = new THREE.Mesh(new THREE.BoxGeometry(arenaSize * 2, wallHeight, 0.5), wallMaterial);
      southWall.position.set(0, wallHeight / 2, arenaSize);
      southWall.castShadow = true;
      scene.add(southWall);
      
      // East wall
      const eastWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, wallHeight, arenaSize * 2), wallMaterial);
      eastWall.position.set(arenaSize, wallHeight / 2, 0);
      eastWall.castShadow = true;
      scene.add(eastWall);
      
      // West wall
      const westWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, wallHeight, arenaSize * 2), wallMaterial);
      westWall.position.set(-arenaSize, wallHeight / 2, 0);
      westWall.castShadow = true;
      scene.add(westWall);
      
      // Store walls in array for bullet hit detection
      const arenaWalls = [northWall, southWall, eastWall, westWall];

      // Cover objects (boxes and walls)
      const coverObjects = [];
      const coverColors = [0xFF6F00, 0x00BCD4, 0xE91E63, 0xFFEB3B, 0x4CAF50];
      
      // Large center box
      const centerBoxTexture = createDotTexture('#FF1744', '#C51162');
      const centerBox = new THREE.Mesh(
          new THREE.BoxGeometry(3, 2, 3),
          new THREE.MeshStandardMaterial({ map: centerBoxTexture, flatShading: true, roughness: 0.8, metalness: 0.1 })
      );
      centerBox.position.set(0, 1, 0);
      centerBox.castShadow = true;
      centerBox.receiveShadow = true;
      scene.add(centerBox);
      coverObjects.push(centerBox);
      
      // Corner boxes
      const corners = [
          { x: -12, z: -12 },
          { x: 12, z: -12 },
          { x: -12, z: 12 },
          { x: 12, z: 12 }
      ];
      corners.forEach((pos, i) => {
          const colorHex = '#' + coverColors[i % coverColors.length].toString(16).padStart(6, '0');
          const darkerColor = '#' + (coverColors[i % coverColors.length] - 0x222222).toString(16).padStart(6, '0');
          const boxTexture = createGridTexture(colorHex, darkerColor);
          const box = new THREE.Mesh(
              new THREE.BoxGeometry(2, 1.5, 2),
              new THREE.MeshStandardMaterial({ map: boxTexture, flatShading: true, roughness: 0.8, metalness: 0.1 })
          );
          box.position.set(pos.x, 0.75, pos.z);
          box.castShadow = true;
          box.receiveShadow = true;
          scene.add(box);
          coverObjects.push(box);
      });
      
      // Small wall covers
      const wallCovers = [
          { x: -8, z: 0, width: 0.5, height: 1.8, depth: 4 },
          { x: 8, z: 0, width: 0.5, height: 1.8, depth: 4 },
          { x: 0, z: -8, width: 4, height: 1.8, depth: 0.5 },
          { x: 0, z: 8, width: 4, height: 1.8, depth: 0.5 }
      ];
      wallCovers.forEach((wall, i) => {
          const wallCoverTexture = createStripedTexture('#00E5FF', '#00B8D4');
          const wallBox = new THREE.Mesh(
              new THREE.BoxGeometry(wall.width, wall.height, wall.depth),
              new THREE.MeshStandardMaterial({ map: wallCoverTexture, flatShading: true, roughness: 0.8, metalness: 0.15 })
          );
          wallBox.position.set(wall.x, wall.height / 2, wall.z);
          wallBox.castShadow = true;
          wallBox.receiveShadow = true;
          scene.add(wallBox);
          coverObjects.push(wallBox);
      });
      
      // Scattered boxes for tactical cover
      const scatteredBoxes = [
          { x: -5, z: -5, size: 1.5 },
          { x: 5, z: 5, size: 1.5 },
          { x: -5, z: 5, size: 1.2 },
          { x: 5, z: -5, size: 1.2 }
      ];
      scatteredBoxes.forEach((box, i) => {
          const colorHex = '#' + coverColors[(i + 2) % coverColors.length].toString(16).padStart(6, '0');
          const lighterColor = '#' + (coverColors[(i + 2) % coverColors.length] + 0x111111).toString(16).padStart(6, '0');
          const scatterTexture = createDotTexture(colorHex, lighterColor);
          const mesh = new THREE.Mesh(
              new THREE.BoxGeometry(box.size, box.size, box.size),
              new THREE.MeshStandardMaterial({ map: scatterTexture, flatShading: true, roughness: 0.8, metalness: 0.1 })
          );
          mesh.position.set(box.x, box.size / 2, box.z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          coverObjects.push(mesh);
      });
      
      // Pre-calculate bounding boxes for collision detection (performance optimization)
      const coverBoundingBoxes = [];
      coverObjects.forEach(cover => {
          const box = new THREE.Box3().setFromObject(cover);
          coverBoundingBoxes.push(box);
      });

      // Bullet impact decals
      const bulletHoles = [];
      const maxBulletHoles = 100;
      
      function createBulletHole(point, normal, hitObject) {
          // Create realistic small bullet hole with smooth edges
          const holeGeometry = new THREE.CircleGeometry(0.03, 32);
          const holeMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x0d0d0d,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.95,
              depthWrite: false
          });
          const hole = new THREE.Mesh(holeGeometry, holeMaterial);
          
          // Add outer ring for softer appearance
          const ringGeometry = new THREE.RingGeometry(0.03, 0.04, 32);
          const ringMaterial = new THREE.MeshBasicMaterial({
              color: 0x2a2a2a,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.4,
              depthWrite: false
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          hole.add(ring);
          
          // Transform normal to world space
          const worldNormal = normal.clone();
          worldNormal.transformDirection(hitObject.matrixWorld);
          worldNormal.normalize();
          
          // Position at hit point with proper offset
          hole.position.copy(point).add(worldNormal.multiplyScalar(0.005));
          
          // CircleGeometry faces up by default (Y-axis), we need to rotate it to face the normal
          // Use lookAt to orient the circle perpendicular to the surface
          const targetPoint = new THREE.Vector3().copy(point).add(worldNormal);
          hole.lookAt(targetPoint);
          
          // Add slight random rotation around the normal axis for variety
          const axis = new THREE.Vector3().copy(worldNormal).normalize();
          hole.rotateOnAxis(axis, Math.random() * Math.PI * 2);
          
          scene.add(hole);
          bulletHoles.push(hole);
          
          // Remove oldest bullet hole if we exceed max
          if (bulletHoles.length > maxBulletHoles) {
              const oldHole = bulletHoles.shift();
              scene.remove(oldHole);
              oldHole.geometry.dispose();
              oldHole.material.dispose();
              // Dispose ring geometry and material
              if (oldHole.children.length > 0) {
                  oldHole.children[0].geometry.dispose();
                  oldHole.children[0].material.dispose();
              }
          }
      }

      // Remove target system for PvP arena

      function createOtherPlayerMesh(playerData) {
          const group = new THREE.Group();

          // Body (cylinder)
          const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 6);
          const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00BCD4, flatShading: true });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          body.position.y = 1.2;
          body.castShadow = true;
          group.add(body);
          group.userData.body = body;

          // Head (sphere)
          const headGeometry = new THREE.SphereGeometry(0.25, 6, 6);
          const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFC107, flatShading: true });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          head.position.y = 2;
          head.castShadow = true;
          group.add(head);

          // Eyes
          const eyeGeometry = new THREE.SphereGeometry(0.06, 4, 4);
          const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true });
          const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
          
          // Left eye (positioned forward on Z axis)
          const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
          leftEye.position.set(-0.08, 2.05, -0.2);
          group.add(leftEye);
          
          const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 6), pupilMaterial);
          leftPupil.position.set(-0.08, 2.05, -0.25);
          group.add(leftPupil);
          
          // Right eye (positioned forward on Z axis)
          const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
          rightEye.position.set(0.08, 2.05, -0.2);
          group.add(rightEye);
          
          const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 6), pupilMaterial);
          rightPupil.position.set(0.08, 2.05, -0.25);
          group.add(rightPupil);

          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = 256;
          canvas.height = 64;
          context.fillStyle = 'rgba(0,0,0,0.7)';
          context.fillRect(0, 0, 256, 64);
          context.fillStyle = 'white';
          context.font = 'bold 32px Arial';
          context.textAlign = 'center';
          context.fillText(playerData.name, 128, 42);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.position.y = 2.5;
          sprite.scale.set(2, 0.5, 1);
          group.add(sprite);
          group.userData.nameSprite = sprite;

          // Health bar background (black border)
          const healthBarBgCanvas = document.createElement('canvas');
          healthBarBgCanvas.width = 128;
          healthBarBgCanvas.height = 16;
          const healthBgCtx = healthBarBgCanvas.getContext('2d');
          healthBgCtx.fillStyle = '#000000';
          healthBgCtx.fillRect(0, 0, 128, 16);
          healthBgCtx.strokeStyle = '#ffffff';
          healthBgCtx.lineWidth = 2;
          healthBgCtx.strokeRect(1, 1, 126, 14);
          
          const healthBarBgTexture = new THREE.CanvasTexture(healthBarBgCanvas);
          const healthBarBgSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
              map: healthBarBgTexture,
              depthTest: false,
              depthWrite: false
          }));
          healthBarBgSprite.position.set(0, 2.3, 0);
          healthBarBgSprite.scale.set(1, 0.12, 1);
          healthBarBgSprite.renderOrder = 1;
          group.add(healthBarBgSprite);
          group.userData.healthBarBg = healthBarBgSprite;

          // Health bar (green bar that changes)
          const healthBarCanvas = document.createElement('canvas');
          healthBarCanvas.width = 120;
          healthBarCanvas.height = 12;
          group.userData.healthBarCanvas = healthBarCanvas;
          group.userData.healthBarContext = healthBarCanvas.getContext('2d');
          
          const healthBarTexture = new THREE.CanvasTexture(healthBarCanvas);
          const healthBarSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
              map: healthBarTexture,
              depthTest: false,
              depthWrite: false
          }));
          healthBarSprite.position.set(0, 2.3, 0.01);
          healthBarSprite.scale.set(0.94, 0.09, 1);
          healthBarSprite.renderOrder = 2;
          group.add(healthBarSprite);
          group.userData.healthBar = healthBarSprite;
          group.userData.healthBarTexture = healthBarTexture;
          
          // Initialize health in userData
          group.userData.health = playerData.health !== undefined ? playerData.health : 100;
          
          // Draw initial full health
          updateHealthBar(group, group.userData.health);

          return group;
      }

      function updateHealthBar(playerMesh, health) {
          const ctx = playerMesh.userData.healthBarContext;
          const canvas = playerMesh.userData.healthBarCanvas;
          if (!ctx || !canvas) return;
          
          const healthPercent = Math.max(0, Math.min(1, health / 100));
          const barWidth = Math.floor(120 * healthPercent);
          
          // Clear canvas
          ctx.clearRect(0, 0, 120, 12);
          
          // Determine color based on health
          let color;
          if (healthPercent > 0.6) {
              color = '#00ff00'; // Green
          } else if (healthPercent > 0.3) {
              color = '#ffff00'; // Yellow
          } else {
              color = '#ff0000'; // Red
          }
          
          // Draw health bar
          ctx.fillStyle = color;
          ctx.fillRect(0, 0, barWidth, 12);
          
          // Update texture
          if (playerMesh.userData.healthBarTexture) {
              playerMesh.userData.healthBarTexture.needsUpdate = true;
          }
      }

      function updateOtherPlayer(data) {
          // Ensure we have a valid mesh, create if needed
          if (!otherPlayerMeshes[data.id]) {
              otherPlayerMeshes[data.id] = createOtherPlayerMesh(data);
              scene.add(otherPlayerMeshes[data.id]);
              console.log('Created new player mesh for:', data.id);
          }

          const playerMesh = otherPlayerMeshes[data.id];
          
          // Ensure mesh is visible
          playerMesh.visible = true;
          
          // Update position - use data.position.y for jumping animation
          // Offset by -1.6 so when camera is at 1.6 (ground), mesh is at y=0
          const meshY = data.position.y - 1.6;
          playerMesh.position.set(data.position.x, meshY, data.position.z);
          
          // Update rotation if provided
          if (data.rotation && data.rotation.y !== undefined) {
              playerMesh.rotation.y = data.rotation.y;
          }

          // Update health bar
          if (data.health !== undefined) {
              // Store health in userData for client-side prediction
              playerMesh.userData.health = data.health;
              updateHealthBar(playerMesh, data.health);
          }

          // Make sprites face camera
          if (playerMesh.userData.nameSprite) {
              playerMesh.userData.nameSprite.lookAt(camera.position);
          }
          if (playerMesh.userData.healthBar) {
              playerMesh.userData.healthBar.lookAt(camera.position);
          }
          if (playerMesh.userData.healthBarBg) {
              playerMesh.userData.healthBarBg.lookAt(camera.position);
          }
      }

      // No targets in PvP arena

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(0, 0);

      const keys = {};
      const moveSpeed = 0.1;

      document.addEventListener('keydown', function(e) {
          if (!e.key) return;
          keys[e.key.toLowerCase()] = true;
          
          // Exit fullscreen with ESC key
          if (e.key === 'Escape' && document.fullscreenElement) {
              document.exitFullscreen();
              return;
          }
          
          // Jump with Space bar
          if (e.key === ' ' && gameActive && !isDead && !isJumping) {
              isJumping = true;
              verticalVelocity = jumpStrength;
          }
          
          if (e.key.toLowerCase() === 'r' && gameActive) {
              reload();
          }
      });

      document.addEventListener('keyup', function(e) {
          if (!e.key) return;
          keys[e.key.toLowerCase()] = false;
      });

      let yaw = 0;
      let pitch = 0;
      let isReloading = false;
      
      function reload() {
          if (isReloading || ammo === 30) return;
          
          isReloading = true;
          playReloadSound();
          
          setTimeout(function() {
              ammo = 30;
              updateUI();
              isReloading = false;
          }, 1500); // 1.5 second reload time
      }

      document.addEventListener('click', function() {
          if (gameActive) {
              document.body.requestPointerLock();
              shoot();
          }
      });

      document.addEventListener('mousemove', function(e) {
          if (document.pointerLockElement === document.body) {
              // Clamp movement values to prevent random swings from large delta spikes
              const maxDelta = 100; // Maximum pixels per frame
              const clampedX = Math.max(-maxDelta, Math.min(maxDelta, e.movementX));
              const clampedY = Math.max(-maxDelta, Math.min(maxDelta, e.movementY));
              
              yaw -= clampedX * 0.002;
              pitch -= clampedY * 0.002;
              pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
          }
      });

      function shoot() {
          if (!gameActive || isDead || isReloading) return;

          if (ammo <= 0) {
              playEmptyClickSound();
              return;
          }

          ammo--;
          updateUI();
          playShootSound();
          
          // Auto-reload immediately when ammo reaches 0
          if (ammo === 0) {
              reload();
          }

          const flash = new THREE.PointLight(0xffaa00, 2, 5);
          flash.position.copy(camera.position);
          scene.add(flash);
          setTimeout(function() {
              scene.remove(flash);
          }, 50);

          raycaster.setFromCamera(mouse, camera);
          
          // Check for hits on other players, cover, walls, and ground
          const otherPlayerObjects = Object.values(otherPlayerMeshes).map(p => p.children).flat();
          const allObjects = [...otherPlayerObjects, ...coverObjects, ...arenaWalls, ground];
          const intersects = raycaster.intersectObjects(allObjects, false);

          if (intersects.length > 0) {
              const hitObject = intersects[0].object;
              
              // Check if we hit cover, walls, or ground
              if (coverObjects.includes(hitObject) || arenaWalls.includes(hitObject) || hitObject === ground) {
                  // Create bullet hole at impact point on all surfaces
                  createBulletHole(
                      intersects[0].point,
                      intersects[0].face.normal.clone(),
                      hitObject
                  );
                  // Bullet stopped by cover/wall/ground
                  return;
              }
              
              // Find which player was hit
              for (let targetId in otherPlayerMeshes) {
                  if (otherPlayerMeshes[targetId].children.includes(intersects[0].object)) {
                      playHitSound();
                      
                      if (isOnline && socket) {
                          socket.emit('shootPlayer', { targetId: targetId });
                      }
                      
                      // Visual feedback
                      if (intersects[0].object.material) {
                          const originalColor = intersects[0].object.material.color.clone();
                          intersects[0].object.material.color.setHex(0xffffff);
                          setTimeout(function() {
                              if (intersects[0].object.material) {
                                  intersects[0].object.material.color.copy(originalColor);
                              }
                          }, 100);
                      }
                      break;
                  }
              }
          }
      }

      function die() {
          isDead = true;
          health = 0;
          deaths++;
          updateUI();
          
          // Disable controls
          document.exitPointerLock();
          
          // Remove any existing death message
          const existingMsg = document.getElementById('deathMessage');
          if (existingMsg) {
              document.body.removeChild(existingMsg);
          }
          
          // Show death message
          const deathMsg = document.createElement('div');
          deathMsg.id = 'deathMessage';
          deathMsg.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:#ff0000;padding:30px;border-radius:10px;font-size:24px;z-index:150;';
          deathMsg.textContent = 'You Died! Respawning in 3...';
          document.body.appendChild(deathMsg);
          
          let countdown = 3;
          const countdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                  deathMsg.textContent = 'You Died! Respawning in ' + countdown + '...';
              } else {
                  clearInterval(countdownInterval);
                  const msg = document.getElementById('deathMessage');
                  if (msg) {
                      document.body.removeChild(msg);
                  }
                  respawn();
              }
          }, 1000);
      }

      function respawn() {
          isDead = false;
          health = 100;
          ammo = 30;
          
          updateUI();
          
          if (isOnline && socket) {
              // Let server decide spawn position
              socket.emit('respawn');
          } else {
              // Offline mode: generate position locally
              const spawnX = (Math.random() - 0.5) * 30;
              const spawnZ = (Math.random() - 0.5) * 30;
              camera.position.set(spawnX, 1.6, spawnZ);
              yaw = Math.random() * Math.PI * 2;
          }
      }

      function updateUI() {
          document.getElementById('health').textContent = health;
          document.getElementById('kills').textContent = kills;
          document.getElementById('deaths').textContent = deaths;
          document.getElementById('ammo').textContent = ammo;
      }

      function updateLeaderboard() {
          const playerList = document.getElementById('playerList');
          const sortedPlayers = Object.values(players).sort(function(a, b) {
              return b.kills - a.kills;
          });

          playerList.innerHTML = sortedPlayers.map(function(player) {
              return '<div class="player-item"><span>' + player.name + '</span><span>' + player.kills + ' / ' + player.deaths + '</span></div>';
          }).join('');
      }

      function joinGame() {
          // Use authenticated username
          playerName = currentUser ? currentUser.username : 'Guest' + Math.floor(Math.random() * 1000);

          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('info').style.display = 'block';
          document.getElementById('leaderboard').style.display = 'block';
          document.getElementById('crosshair').style.display = 'block';

          gameActive = true;
          
          // Enter fullscreen
          if (document.documentElement.requestFullscreen) {
              document.documentElement.requestFullscreen().catch(err => {
                  console.log('Fullscreen request failed:', err);
              });
          }

          if (isOnline && socket) {
              socket.emit('joinGame', { 
                  name: playerName,
                  userId: currentUser ? currentUser.userId : null
              });
              socket.on('playerInfo', function(data) {
                  playerId = data.id;
                  players = data.players;
                  
                  // Clear all existing meshes first (in case of rejoin)
                  for (let meshId in otherPlayerMeshes) {
                      scene.remove(otherPlayerMeshes[meshId]);
                      delete otherPlayerMeshes[meshId];
                  }
                  
                  // Create meshes for all existing players except ourselves
                  for (let id in players) {
                      if (id !== playerId) {
                          otherPlayerMeshes[id] = createOtherPlayerMesh(players[id]);
                          otherPlayerMeshes[id].position.set(
                              players[id].position.x,
                              0,
                              players[id].position.z
                          );
                          scene.add(otherPlayerMeshes[id]);
                          console.log('Created mesh for existing player:', id);
                      }
                  }
                  
                  updateLeaderboard();
              });
          } else {
              playerId = 'local';
              players[playerId] = { name: playerName, kills: 0, deaths: 0, health: 100 };
              updateLeaderboard();
          }
      }

      // No timer needed for arena mode
      
      // Reusable vectors for performance (avoid creating new objects every frame)
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      const playerBoxMin = new THREE.Vector3();
      const playerBoxMax = new THREE.Vector3();
      const playerBox = new THREE.Box3();

      let lastPositionUpdate = 0;
      function animate() {
          requestAnimationFrame(animate);

          if (gameActive) {
              forward.set(0, 0, -1).applyQuaternion(camera.quaternion);
              right.set(1, 0, 0).applyQuaternion(camera.quaternion);

              forward.y = 0;
              right.y = 0;
              forward.normalize();
              right.normalize();

              if (!isDead) {
                  if (keys['w']) camera.position.add(forward.multiplyScalar(moveSpeed));
                  if (keys['s']) camera.position.add(forward.multiplyScalar(-moveSpeed));
                  if (keys['a']) camera.position.add(right.multiplyScalar(-moveSpeed));
                  if (keys['d']) camera.position.add(right.multiplyScalar(moveSpeed));

                  // Arena boundaries
                  camera.position.x = Math.max(-19, Math.min(19, camera.position.x));
                  camera.position.z = Math.max(-19, Math.min(19, camera.position.z));
                  
                  // Collision detection with cover objects (optimized with smooth pushback)
                  const playerRadius = 0.5;
                  const prevX = camera.position.x;
                  const prevZ = camera.position.z;
                  
                  playerBoxMin.set(
                      camera.position.x - playerRadius,
                      0,
                      camera.position.z - playerRadius
                  );
                  playerBoxMax.set(
                      camera.position.x + playerRadius,
                      2,
                      camera.position.z + playerRadius
                  );
                  playerBox.set(playerBoxMin, playerBoxMax);
                  
                  for (let i = 0; i < coverBoundingBoxes.length; i++) {
                      const box = coverBoundingBoxes[i];
                      
                      if (box.intersectsBox(playerBox)) {
                          // Collision detected, smoothly push player back to previous position
                          const centerX = (box.min.x + box.max.x) / 2;
                          const centerZ = (box.min.z + box.max.z) / 2;
                          const dx = camera.position.x - centerX;
                          const dz = camera.position.z - centerZ;
                          
                          // Calculate minimum distance to push out
                          const overlapX = playerRadius + (box.max.x - box.min.x) / 2 - Math.abs(dx);
                          const overlapZ = playerRadius + (box.max.z - box.min.z) / 2 - Math.abs(dz);
                          
                          // Push along the axis with smallest overlap for smoother collision
                          if (overlapX < overlapZ) {
                              camera.position.x += dx > 0 ? overlapX : -overlapX;
                          } else {
                              camera.position.z += dz > 0 ? overlapZ : -overlapZ;
                          }
                      }
                  }
              }
              
              // Jump physics
              if (isJumping) {
                  verticalVelocity += gravity;
                  camera.position.y += verticalVelocity;
                  
                  // Land on ground
                  if (camera.position.y <= groundLevel) {
                      camera.position.y = groundLevel;
                      isJumping = false;
                      verticalVelocity = 0;
                  }
              } else {
                  camera.position.y = groundLevel;
              }

              camera.rotation.order = 'YXZ';
              camera.rotation.y = yaw;
              camera.rotation.x = pitch;

              const now = Date.now();
              if (isOnline && socket && now - lastPositionUpdate > 50) {
                  socket.emit('playerMove', {
                      position: camera.position,
                      rotation: { y: yaw },
                      health: health,
                      isJumping: isJumping
                  });
                  lastPositionUpdate = now;
              }
          }

          renderer.render(scene, camera);
      }

      window.addEventListener('resize', function() {
          camera.aspect = window. innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
