<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arena Shooter - 8 Players</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 100;
      }
      #leaderboard {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        min-width: 200px;
      }
      #leaderboard h3 {
        margin: 0 0 10px 0;
        color: #4caf50;
      }
      .player-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        border: 2px solid red;
        border-radius: 50%;
        pointer-events: none;
        z-index: 100;
      }
      #crosshair::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 2px;
        height: 2px;
        background: red;
      }
      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 40px;
        border-radius: 10px;
        text-align: center;
        display: none;
        z-index: 200;
      }
      #gameOver h1 {
        margin: 0 0 20px 0;
        color: #4caf50;
      }
      #gameOver button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
      }
      #gameOverbutton:hover {
        background: #45a049;
      }
      #startScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 40px;
        border-radius: 10px;
        text-align: center;
        z-index: 200;
      }
      #startScreen h1 {
        margin: 0 0 20px 0;
        color: #4caf50;
      }
      #startScreen input {
        padding: 10px;
        font-size: 16px;
        margin: 10px 0;
        width: 200px;
        border-radius: 5px;
        border: none;
      }
      #startScreen button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        display: block;
        width: 100%;
      }
      #startScreen button:hover {
        background: #45a049;
      }
      #connectionStatus {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 100;
      }
      .online {
        color: #4caf50;
      }
      .offline {
        color: #f44336;
      }
    </style>
  </head>
  <body>
    <div id="startScreen">
      <h1>‚öîÔ∏è Arena Shooter (8 Players)</h1>
      <p>Enter your name to join the battle!</p>
      <input
        type="text"
        id="playerName"
        placeholder="Your Name"
        maxlength="15"
      />
      <p style="font-size: 14px; margin-top: 20px">
        WASD - Move | Mouse - Look | Click - Shoot | R - Reload
      </p>
      <button onclick="joinGame()">Join Game</button>
    </div>
    <div id="info" style="display: none">
      <div>Health: <span id="health">100</span></div>
      <div>Kills: <span id="kills">0</span></div>
      <div>Deaths: <span id="deaths">0</span></div>
      <div>Ammo: <span id="ammo">30</span></div>
      <div style="margin-top: 10px; font-size: 12px">
        WASD - Move | Mouse - Look | Click - Shoot | R - Reload
      </div>
    </div>
    <div id="leaderboard" style="display: none">
      <h3>üèÜ Leaderboard</h3>
      <div id="playerList"></div>
    </div>
    <div id="crosshair" style="display: none"></div>
    <div id="gameOver">
      <h1>Game Over!</h1>
      <p>Your Final Score: <span id="finalScore">0</span></p>
      <div id="finalLeaderboard"></div>
      <button onclick="location.reload()">Play Again</button>
    </div>
    <div id="connectionStatus">
      <span class="offline">‚ö´ Connecting...</span>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      function playShootSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator. frequency.value = 200;
          oscillator.type = 'sawtooth';
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
      }

      function playHitSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode. connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext. currentTime + 0.2);
      }

      function playBullseyeSound() {
          const osc1 = audioContext.createOscillator();
          const gain1 = audioContext.createGain();
          osc1.connect(gain1);
          gain1.connect(audioContext.destination);
          osc1.frequency.value = 1000;
          osc1.type = 'sine';
          gain1.gain.setValueAtTime(0.4, audioContext.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc1.start(audioContext.currentTime);
          osc1.stop(audioContext.currentTime + 0.3);

          const osc2 = audioContext.createOscillator();
          const gain2 = audioContext.createGain();
          osc2.connect(gain2);
          gain2.connect(audioContext.destination);
          osc2.frequency. value = 1500;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.3, audioContext.currentTime + 0.05);
          gain2.gain. exponentialRampToValueAtTime(0.01, audioContext. currentTime + 0.35);
          osc2.start(audioContext.currentTime + 0.05);
          osc2.stop(audioContext. currentTime + 0.35);
      }

      function playReloadSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode. connect(audioContext.destination);
          oscillator.frequency.value = 100;
          oscillator.type = 'square';
          gainNode.gain. setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext. currentTime + 0.15);

          setTimeout(function() {
              const osc2 = audioContext.createOscillator();
              const gain2 = audioContext.createGain();
              osc2.connect(gain2);
              gain2.connect(audioContext.destination);
              osc2.frequency. setValueAtTime(400, audioContext.currentTime);
              osc2.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
              osc2.type = 'sawtooth';
              gain2.gain.setValueAtTime(0.15, audioContext.currentTime);
              gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
              osc2.start(audioContext.currentTime);
              osc2.stop(audioContext.currentTime + 0.3);
          }, 100);
      }

      function playEmptyClickSound() {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.value = 150;
          oscillator.type = 'square';
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.05);
      }

      function playDamageSound() {
          // Red screen flash effect
          const flash = document.createElement('div');
          flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.3);pointer-events:none;z-index:9999;';
          document.body.appendChild(flash);
          setTimeout(() => document.body.removeChild(flash), 100);

          // Pain sound - low thud with descending tone
          const osc1 = audioContext.createOscillator();
          const gain1 = audioContext.createGain();
          osc1.connect(gain1);
          gain1.connect(audioContext.destination);
          osc1.frequency.setValueAtTime(300, audioContext.currentTime);
          osc1.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
          osc1.type = 'sawtooth';
          gain1.gain.setValueAtTime(0.6, audioContext.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc1.start(audioContext.currentTime);
          osc1.stop(audioContext.currentTime + 0.3);

          // Impact sound
          const osc2 = audioContext.createOscillator();
          const gain2 = audioContext.createGain();
          osc2.connect(gain2);
          gain2.connect(audioContext.destination);
          osc2.frequency.value = 80;
          osc2.type = 'triangle';
          gain2.gain.setValueAtTime(0.5, audioContext.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          osc2.start(audioContext.currentTime);
          osc2.stop(audioContext.currentTime + 0.15);
      }

      let socket = null;
      let isOnline = false;
      let playerName = '';
      let playerId = null;
      let health = 100;
      let kills = 0;
      let deaths = 0;
      let ammo = 30;
      let gameActive = false;
      let players = {};
      let otherPlayerMeshes = {};
      let isDead = false;
      let respawnTimer = null;
      
      // Jump variables
      let isJumping = false;
      let verticalVelocity = 0;
      const gravity = -0.015;
      const jumpStrength = 0.3;
      const groundLevel = 1.6;

      const SERVER_URL = window.location.origin;
      try {
          socket = io(SERVER_URL, {
              reconnection: true,
              reconnectionDelay: 1000,
              reconnectionAttempts: 5
          });

          socket.on('connect', function() {
              isOnline = true;
              document.getElementById('connectionStatus').innerHTML = '<span class="online">üü¢ Online</span>';
          });

          socket.on('disconnect', function() {
              isOnline = false;
              document.getElementById('connectionStatus').innerHTML = '<span class="offline">‚ö´ Disconnected</span>';
          });

          socket.on('playerJoined', function(data) {
              players = data.players;
              
              // Remove meshes for players that no longer exist
              for (let meshId in otherPlayerMeshes) {
                  if (!players[meshId]) {
                      console.log('Cleaning up old player mesh:', meshId);
                      scene.remove(otherPlayerMeshes[meshId]);
                      delete otherPlayerMeshes[meshId];
                  }
              }
              
              // Create meshes for any new players we don't have yet
              for (let id in players) {
                  if (id !== playerId && !otherPlayerMeshes[id]) {
                      otherPlayerMeshes[id] = createOtherPlayerMesh(players[id]);
                      otherPlayerMeshes[id].position.set(
                          players[id].position.x,
                          0,
                          players[id].position.z
                      );
                      scene.add(otherPlayerMeshes[id]);
                      console.log('Created mesh for new player:', id);
                  }
              }
              updateLeaderboard();
          });

          socket.on('playerLeft', function(data) {
              players = data.players;
              if (otherPlayerMeshes[data.playerId]) {
                  console.log('Removing player mesh:', data.playerId);
                  scene.remove(otherPlayerMeshes[data.playerId]);
                  delete otherPlayerMeshes[data.playerId];
              }
              updateLeaderboard();
          });

          socket.on('statsUpdate', function(data) {
              players = data.players;
              updateLeaderboard();
          });

          socket.on('playerHit', function(data) {
              if (data.victimId === playerId) {
                  health = data.health;
                  updateUI();
                  
                  // Play damage sound and visual effect
                  playDamageSound();
                  
                  if (health <= 0) {
                      die();
                  }
              }
          });

          socket.on('playerDied', function(data) {
              // Hide the killed player's mesh
              if (otherPlayerMeshes[data.victimId]) {
                  otherPlayerMeshes[data.victimId].visible = false;
              }
          });

          socket.on('playerRespawned', function(data) {
              // Make sure we update the existing player, not create a new one
              if (data.id !== playerId) {
                  // Show and update the respawned player
                  if (otherPlayerMeshes[data.id]) {
                      otherPlayerMeshes[data.id].visible = true;
                  }
                  updateOtherPlayer(data);
              } else {
                  // Update our own position from server (for respawn)
                  if (data.position) {
                      camera.position.set(data.position.x, data.position.y, data.position.z);
                  }
                  if (data.rotation && data.rotation.y !== undefined) {
                      yaw = data.rotation.y;
                  }
              }
          });

          socket.on('forceRespawn', function(data) {
              // Force respawn if we're stuck dead (inactive tab)
              if (isDead) {
                  const deathMsg = document.getElementById('deathMessage');
                  if (deathMsg) {
                      document.body.removeChild(deathMsg);
                  }
                  
                  isDead = false;
                  health = 100;
                  ammo = 30;
                  camera.position.set(data.position.x, data.position.y, data.position.z);
                  updateUI();
              }
          });

          socket.on('playerMoved', function(data) {
              if (data.id !== playerId) {
                  updateOtherPlayer(data);
              }
          });

          socket.on('maxPlayersReached', function() {
              alert('Arena is full! Maximum 2 players allowed.');
              location.reload();
          });

      } catch (e) {
          console.log('Running in offline mode');
          isOnline = false;
          document.getElementById('connectionStatus').innerHTML = '<span class="offline">‚ö´ Offline Mode</span>';
      }

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);

      const renderer = new THREE.WebGLRenderer({ antialias:  true });
      renderer.setSize(window.innerWidth, window. innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
      sunLight.position.set(10, 20, 10);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -50;
      sunLight.shadow. camera.right = 50;
      sunLight.shadow.camera. top = 50;
      sunLight.shadow.camera.bottom = -50;
      scene.add(sunLight);

      const groundGeometry = new THREE.PlaneGeometry(40, 40);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Arena walls
      const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, transparent: true, opacity: 0.7 });
      const wallHeight = 3;
      const arenaSize = 20;
      
      // North wall
      const northWall = new THREE.Mesh(new THREE.BoxGeometry(arenaSize * 2, wallHeight, 0.5), wallMaterial);
      northWall.position.set(0, wallHeight / 2, -arenaSize);
      northWall.castShadow = true;
      scene.add(northWall);
      
      // South wall
      const southWall = new THREE.Mesh(new THREE.BoxGeometry(arenaSize * 2, wallHeight, 0.5), wallMaterial);
      southWall.position.set(0, wallHeight / 2, arenaSize);
      southWall.castShadow = true;
      scene.add(southWall);
      
      // East wall
      const eastWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, wallHeight, arenaSize * 2), wallMaterial);
      eastWall.position.set(arenaSize, wallHeight / 2, 0);
      eastWall.castShadow = true;
      scene.add(eastWall);
      
      // West wall
      const westWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, wallHeight, arenaSize * 2), wallMaterial);
      westWall.position.set(-arenaSize, wallHeight / 2, 0);
      westWall.castShadow = true;
      scene.add(westWall);

      // Cover objects (boxes and walls)
      const coverObjects = [];
      const coverMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
      
      // Large center box
      const centerBox = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), coverMaterial);
      centerBox.position.set(0, 1, 0);
      centerBox.castShadow = true;
      centerBox.receiveShadow = true;
      scene.add(centerBox);
      coverObjects.push(centerBox);
      
      // Corner boxes
      const corners = [
          { x: -12, z: -12 },
          { x: 12, z: -12 },
          { x: -12, z: 12 },
          { x: 12, z: 12 }
      ];
      corners.forEach(pos => {
          const box = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), coverMaterial);
          box.position.set(pos.x, 0.75, pos.z);
          box.castShadow = true;
          box.receiveShadow = true;
          scene.add(box);
          coverObjects.push(box);
      });
      
      // Small wall covers
      const wallCovers = [
          { x: -8, z: 0, width: 0.5, height: 1.8, depth: 4 },
          { x: 8, z: 0, width: 0.5, height: 1.8, depth: 4 },
          { x: 0, z: -8, width: 4, height: 1.8, depth: 0.5 },
          { x: 0, z: 8, width: 4, height: 1.8, depth: 0.5 }
      ];
      wallCovers.forEach(wall => {
          const wallBox = new THREE.Mesh(
              new THREE.BoxGeometry(wall.width, wall.height, wall.depth),
              new THREE.MeshStandardMaterial({ color: 0x8B7355 })
          );
          wallBox.position.set(wall.x, wall.height / 2, wall.z);
          wallBox.castShadow = true;
          wallBox.receiveShadow = true;
          scene.add(wallBox);
          coverObjects.push(wallBox);
      });
      
      // Scattered boxes for tactical cover
      const scatteredBoxes = [
          { x: -5, z: -5, size: 1.5 },
          { x: 5, z: 5, size: 1.5 },
          { x: -5, z: 5, size: 1.2 },
          { x: 5, z: -5, size: 1.2 }
      ];
      scatteredBoxes.forEach(box => {
          const mesh = new THREE.Mesh(
              new THREE.BoxGeometry(box.size, box.size, box.size),
              coverMaterial
          );
          mesh.position.set(box.x, box.size / 2, box.z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          coverObjects.push(mesh);
      });
      
      // Pre-calculate bounding boxes for collision detection (performance optimization)
      const coverBoundingBoxes = [];
      coverObjects.forEach(cover => {
          const box = new THREE.Box3().setFromObject(cover);
          coverBoundingBoxes.push(box);
      });

      // Remove target system for PvP arena

      function createOtherPlayerMesh(playerData) {
          const group = new THREE.Group();

          // Body (cylinder)
          const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
          const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          body.position.y = 1.2;
          body.castShadow = true;
          group.add(body);
          group.userData.body = body;

          // Head (sphere)
          const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
          const headMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          head.position.y = 2;
          head.castShadow = true;
          group.add(head);

          // Eyes
          const eyeGeometry = new THREE.SphereGeometry(0.06, 6, 6);
          const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
          const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
          
          // Left eye (positioned forward on Z axis)
          const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
          leftEye.position.set(-0.08, 2.05, -0.2);
          group.add(leftEye);
          
          const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 6), pupilMaterial);
          leftPupil.position.set(-0.08, 2.05, -0.25);
          group.add(leftPupil);
          
          // Right eye (positioned forward on Z axis)
          const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
          rightEye.position.set(0.08, 2.05, -0.2);
          group.add(rightEye);
          
          const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 6), pupilMaterial);
          rightPupil.position.set(0.08, 2.05, -0.25);
          group.add(rightPupil);

          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = 256;
          canvas.height = 64;
          context.fillStyle = 'rgba(0,0,0,0.7)';
          context.fillRect(0, 0, 256, 64);
          context.fillStyle = 'white';
          context.font = 'bold 32px Arial';
          context.textAlign = 'center';
          context.fillText(playerData.name, 128, 42);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.position.y = 2.5;
          sprite.scale.set(2, 0.5, 1);
          group.add(sprite);
          group.userData.nameSprite = sprite;

          // Health bar background (black border)
          const healthBarBgCanvas = document.createElement('canvas');
          healthBarBgCanvas.width = 128;
          healthBarBgCanvas.height = 16;
          const healthBgCtx = healthBarBgCanvas.getContext('2d');
          healthBgCtx.fillStyle = '#000000';
          healthBgCtx.fillRect(0, 0, 128, 16);
          healthBgCtx.strokeStyle = '#ffffff';
          healthBgCtx.lineWidth = 2;
          healthBgCtx.strokeRect(1, 1, 126, 14);
          
          const healthBarBgTexture = new THREE.CanvasTexture(healthBarBgCanvas);
          const healthBarBgSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
              map: healthBarBgTexture,
              depthTest: false,
              depthWrite: false
          }));
          healthBarBgSprite.position.set(0, 2.3, 0);
          healthBarBgSprite.scale.set(1, 0.12, 1);
          healthBarBgSprite.renderOrder = 1;
          group.add(healthBarBgSprite);
          group.userData.healthBarBg = healthBarBgSprite;

          // Health bar (green bar that changes)
          const healthBarCanvas = document.createElement('canvas');
          healthBarCanvas.width = 120;
          healthBarCanvas.height = 12;
          group.userData.healthBarCanvas = healthBarCanvas;
          group.userData.healthBarContext = healthBarCanvas.getContext('2d');
          
          const healthBarTexture = new THREE.CanvasTexture(healthBarCanvas);
          const healthBarSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
              map: healthBarTexture,
              depthTest: false,
              depthWrite: false
          }));
          healthBarSprite.position.set(0, 2.3, 0.01);
          healthBarSprite.scale.set(0.94, 0.09, 1);
          healthBarSprite.renderOrder = 2;
          group.add(healthBarSprite);
          group.userData.healthBar = healthBarSprite;
          group.userData.healthBarTexture = healthBarTexture;
          
          // Initialize health in userData
          group.userData.health = playerData.health !== undefined ? playerData.health : 100;
          
          // Draw initial full health
          updateHealthBar(group, group.userData.health);

          return group;
      }

      function updateHealthBar(playerMesh, health) {
          const ctx = playerMesh.userData.healthBarContext;
          const canvas = playerMesh.userData.healthBarCanvas;
          if (!ctx || !canvas) return;
          
          const healthPercent = Math.max(0, Math.min(1, health / 100));
          const barWidth = Math.floor(120 * healthPercent);
          
          // Clear canvas
          ctx.clearRect(0, 0, 120, 12);
          
          // Determine color based on health
          let color;
          if (healthPercent > 0.6) {
              color = '#00ff00'; // Green
          } else if (healthPercent > 0.3) {
              color = '#ffff00'; // Yellow
          } else {
              color = '#ff0000'; // Red
          }
          
          // Draw health bar
          ctx.fillStyle = color;
          ctx.fillRect(0, 0, barWidth, 12);
          
          // Update texture
          if (playerMesh.userData.healthBarTexture) {
              playerMesh.userData.healthBarTexture.needsUpdate = true;
          }
      }

      function updateOtherPlayer(data) {
          // Ensure we have a valid mesh, create if needed
          if (!otherPlayerMeshes[data.id]) {
              otherPlayerMeshes[data.id] = createOtherPlayerMesh(data);
              scene.add(otherPlayerMeshes[data.id]);
              console.log('Created new player mesh for:', data.id);
          }

          const playerMesh = otherPlayerMeshes[data.id];
          
          // Ensure mesh is visible
          playerMesh.visible = true;
          
          // Update position - use data.position.y for jumping animation
          // Offset by -1.6 so when camera is at 1.6 (ground), mesh is at y=0
          const meshY = data.position.y - 1.6;
          playerMesh.position.set(data.position.x, meshY, data.position.z);
          
          // Update rotation if provided
          if (data.rotation && data.rotation.y !== undefined) {
              playerMesh.rotation.y = data.rotation.y;
          }

          // Update health bar
          if (data.health !== undefined) {
              // Store health in userData for client-side prediction
              playerMesh.userData.health = data.health;
              updateHealthBar(playerMesh, data.health);
          }

          // Make sprites face camera
          if (playerMesh.userData.nameSprite) {
              playerMesh.userData.nameSprite.lookAt(camera.position);
          }
          if (playerMesh.userData.healthBar) {
              playerMesh.userData.healthBar.lookAt(camera.position);
          }
          if (playerMesh.userData.healthBarBg) {
              playerMesh.userData.healthBarBg.lookAt(camera.position);
          }
      }

      // No targets in PvP arena

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(0, 0);

      const keys = {};
      const moveSpeed = 0.1;

      document.addEventListener('keydown', function(e) {
          if (!e.key) return;
          keys[e.key.toLowerCase()] = true;
          
          // Jump with Space bar
          if (e.key === ' ' && gameActive && !isDead && !isJumping) {
              isJumping = true;
              verticalVelocity = jumpStrength;
          }
          
          if (e.key.toLowerCase() === 'r' && gameActive) {
              if (ammo < 30) {
                  ammo = 30;
                  updateUI();
                  playReloadSound();
              }
          }
      });

      document.addEventListener('keyup', function(e) {
          if (!e.key) return;
          keys[e.key.toLowerCase()] = false;
      });

      let yaw = 0;
      let pitch = 0;

      document.addEventListener('click', function() {
          if (gameActive) {
              document.body.requestPointerLock();
              shoot();
          }
      });

      document.addEventListener('mousemove', function(e) {
          if (document.pointerLockElement === document.body) {
              yaw -= e.movementX * 0.002;
              pitch -= e.movementY * 0.002;
              pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
          }
      });

      function shoot() {
          if (!gameActive || isDead) return;

          if (ammo <= 0) {
              playEmptyClickSound();
              return;
          }

          ammo--;
          updateUI();
          playShootSound();

          const flash = new THREE.PointLight(0xffaa00, 2, 5);
          flash.position.copy(camera.position);
          scene.add(flash);
          setTimeout(function() {
              scene.remove(flash);
          }, 50);

          raycaster.setFromCamera(mouse, camera);
          
          // Check for hits on other players and cover
          const otherPlayerObjects = Object.values(otherPlayerMeshes).map(p => p.children).flat();
          const allObjects = [...otherPlayerObjects, ...coverObjects];
          const intersects = raycaster.intersectObjects(allObjects, false);

          if (intersects.length > 0) {
              // Check if we hit cover first (cover blocks the shot)
              if (coverObjects.includes(intersects[0].object)) {
                  // Hit cover, bullet stopped
                  return;
              }
              
              // Find which player was hit
              for (let targetId in otherPlayerMeshes) {
                  if (otherPlayerMeshes[targetId].children.includes(intersects[0].object)) {
                      playHitSound();
                      
                      if (isOnline && socket) {
                          socket.emit('shootPlayer', { targetId: targetId });
                      }
                      
                      // Visual feedback
                      if (intersects[0].object.material) {
                          const originalColor = intersects[0].object.material.color.clone();
                          intersects[0].object.material.color.setHex(0xffffff);
                          setTimeout(function() {
                              if (intersects[0].object.material) {
                                  intersects[0].object.material.color.copy(originalColor);
                              }
                          }, 100);
                      }
                      break;
                  }
              }
          }
      }

      function die() {
          isDead = true;
          health = 0;
          deaths++;
          updateUI();
          
          // Disable controls
          document.exitPointerLock();
          
          // Remove any existing death message
          const existingMsg = document.getElementById('deathMessage');
          if (existingMsg) {
              document.body.removeChild(existingMsg);
          }
          
          // Show death message
          const deathMsg = document.createElement('div');
          deathMsg.id = 'deathMessage';
          deathMsg.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:#ff0000;padding:30px;border-radius:10px;font-size:24px;z-index:150;';
          deathMsg.textContent = 'You Died! Respawning in 3...';
          document.body.appendChild(deathMsg);
          
          let countdown = 3;
          const countdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                  deathMsg.textContent = 'You Died! Respawning in ' + countdown + '...';
              } else {
                  clearInterval(countdownInterval);
                  const msg = document.getElementById('deathMessage');
                  if (msg) {
                      document.body.removeChild(msg);
                  }
                  respawn();
              }
          }, 1000);
      }

      function respawn() {
          isDead = false;
          health = 100;
          ammo = 30;
          
          updateUI();
          
          if (isOnline && socket) {
              // Let server decide spawn position
              socket.emit('respawn');
          } else {
              // Offline mode: generate position locally
              const spawnX = (Math.random() - 0.5) * 30;
              const spawnZ = (Math.random() - 0.5) * 30;
              camera.position.set(spawnX, 1.6, spawnZ);
              yaw = Math.random() * Math.PI * 2;
          }
      }

      function updateUI() {
          document.getElementById('health').textContent = health;
          document.getElementById('kills').textContent = kills;
          document.getElementById('deaths').textContent = deaths;
          document.getElementById('ammo').textContent = ammo;
      }

      function updateLeaderboard() {
          const playerList = document.getElementById('playerList');
          const sortedPlayers = Object.values(players).sort(function(a, b) {
              return b.kills - a.kills;
          });

          playerList.innerHTML = sortedPlayers.map(function(player) {
              return '<div class="player-item"><span>' + player.name + '</span><span>' + player.kills + ' / ' + player.deaths + '</span></div>';
          }).join('');
      }

      function joinGame() {
          const nameInput = document.getElementById('playerName');
          playerName = nameInput.value.trim() || 'Player' + Math.floor(Math.random() * 1000);

          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('info').style.display = 'block';
          document.getElementById('leaderboard').style.display = 'block';
          document.getElementById('crosshair').style.display = 'block';

          gameActive = true;

          if (isOnline && socket) {
              socket.emit('joinGame', { name: playerName });
              socket.on('playerInfo', function(data) {
                  playerId = data.id;
                  players = data.players;
                  
                  // Clear all existing meshes first (in case of rejoin)
                  for (let meshId in otherPlayerMeshes) {
                      scene.remove(otherPlayerMeshes[meshId]);
                      delete otherPlayerMeshes[meshId];
                  }
                  
                  // Create meshes for all existing players except ourselves
                  for (let id in players) {
                      if (id !== playerId) {
                          otherPlayerMeshes[id] = createOtherPlayerMesh(players[id]);
                          otherPlayerMeshes[id].position.set(
                              players[id].position.x,
                              0,
                              players[id].position.z
                          );
                          scene.add(otherPlayerMeshes[id]);
                          console.log('Created mesh for existing player:', id);
                      }
                  }
                  
                  updateLeaderboard();
              });
          } else {
              playerId = 'local';
              players[playerId] = { name: playerName, kills: 0, deaths: 0, health: 100 };
              updateLeaderboard();
          }
      }

      // No timer needed for arena mode
      
      // Reusable vectors for performance (avoid creating new objects every frame)
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      const playerBoxMin = new THREE.Vector3();
      const playerBoxMax = new THREE.Vector3();
      const playerBox = new THREE.Box3();

      let lastPositionUpdate = 0;
      function animate() {
          requestAnimationFrame(animate);

          if (gameActive) {
              forward.set(0, 0, -1).applyQuaternion(camera.quaternion);
              right.set(1, 0, 0).applyQuaternion(camera.quaternion);

              forward.y = 0;
              right.y = 0;
              forward.normalize();
              right.normalize();

              if (!isDead) {
                  if (keys['w']) camera.position.add(forward.multiplyScalar(moveSpeed));
                  if (keys['s']) camera.position.add(forward.multiplyScalar(-moveSpeed));
                  if (keys['a']) camera.position.add(right.multiplyScalar(-moveSpeed));
                  if (keys['d']) camera.position.add(right.multiplyScalar(moveSpeed));

                  // Arena boundaries
                  camera.position.x = Math.max(-19, Math.min(19, camera.position.x));
                  camera.position.z = Math.max(-19, Math.min(19, camera.position.z));
                  
                  // Collision detection with cover objects (optimized)
                  const playerRadius = 0.5;
                  playerBoxMin.set(
                      camera.position.x - playerRadius,
                      0,
                      camera.position.z - playerRadius
                  );
                  playerBoxMax.set(
                      camera.position.x + playerRadius,
                      2,
                      camera.position.z + playerRadius
                  );
                  playerBox.set(playerBoxMin, playerBoxMax);
                  
                  for (let i = 0; i < coverBoundingBoxes.length; i++) {
                      const box = coverBoundingBoxes[i];
                      
                      if (box.intersectsBox(playerBox)) {
                          // Collision detected, push player back
                          const centerX = (box.min.x + box.max.x) / 2;
                          const centerZ = (box.min.z + box.max.z) / 2;
                          const dx = camera.position.x - centerX;
                          const dz = camera.position.z - centerZ;
                          
                          if (Math.abs(dx) > Math.abs(dz)) {
                              camera.position.x = dx > 0 ? box.max.x + playerRadius : box.min.x - playerRadius;
                          } else {
                              camera.position.z = dz > 0 ? box.max.z + playerRadius : box.min.z - playerRadius;
                          }
                      }
                  }
              }
              
              // Jump physics
              if (isJumping) {
                  verticalVelocity += gravity;
                  camera.position.y += verticalVelocity;
                  
                  // Land on ground
                  if (camera.position.y <= groundLevel) {
                      camera.position.y = groundLevel;
                      isJumping = false;
                      verticalVelocity = 0;
                  }
              } else {
                  camera.position.y = groundLevel;
              }

              camera.rotation.order = 'YXZ';
              camera.rotation.y = yaw;
              camera.rotation.x = pitch;

              const now = Date.now();
              if (isOnline && socket && now - lastPositionUpdate > 50) {
                  socket.emit('playerMove', {
                      position: camera.position,
                      rotation: { y: yaw },
                      health: health,
                      isJumping: isJumping
                  });
                  lastPositionUpdate = now;
              }
          }

          renderer.render(scene, camera);
      }

      window.addEventListener('resize', function() {
          camera.aspect = window. innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
